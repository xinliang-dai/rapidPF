{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RapidPF","text":""},{"location":"#rapid-prototyping-for-distributed-power-flow-problems","title":"Rapid prototyping for distributed power flow problems","text":"<p>The power flow problem is the cornerstone problem in power systems analysis: find all (complex) quantities in an AC electrical network in steady state. Mathematically, the power flow problem is a system of nonlinear equations</p> g(x) = 0 <p>that can be solved by the Newton method, for instance. However, the power flow problem can also be solved in a distributed fashion,</p> <p>$$ \\begin{align} g_{i}(x_i) &amp;= 0, \\\\ \\sum_{i = 1}^{n} A_i x_i &amp;= 0, \\end{align} $$ where i \\in \\{ 1, \\dots, n\\} corresponds to the i-th subproblem. In plain words, the distributed power flow problem means</p> <p>to solve a power flow problem within each region i whilst ensuring that the neighboring power flows satisfy the overall power flow equations.</p> <p>There are several advantages of distributed approaches:</p> <ul> <li>distribute computational effort,</li> <li>preserves privacy,</li> <li>increases reliability,</li> <li>and adds flexibility.</li> </ul>"},{"location":"#what-to-expect","title":"What to expect","text":"<p>The code allows to formulate distributed power flow problems easily. Specifically, the features of the code include:</p> <ul> <li>Starting from several individual case files, generate a merged case file for given connections.</li> <li>Formulate distributed power flow problems in terms of function handles.</li> <li>Solve distributed power flow problems using the Aladin toolbox.</li> <li>Fully compliant with <code>matpower</code> case files, hence allowing to use all of the built-in <code>matpower</code> functions.</li> <li>Insightful post-processing features.</li> </ul>"},{"location":"#what-not-to-expect","title":"What not to expect","text":"<ul> <li>An introduction to the power flow problem as such. There are excellent references for this, for example this one</li> <li>Optimal power flow problems.</li> <li>A collection of numerical routines to solve distributed power flow problems.</li> <li>A visualizer of <code>matpower</code> case files; use STAC for this.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>See here.</p> <p>Use of <code>matpower</code></p> <p>The code relies heavily on <code>Matpower</code>, especially on the idea of a <code>matpower case file</code> (or <code>mpc</code>). This bulky name is nothing but a standardized <code>Matlab</code> struct, with the advantage that it has become a de facto standard for Matlab-based power systems research. Also, <code>mpc</code> can be converted within <code>matpower</code> to/from IEEE CDF or PSS/E RAW, see the <code>Matpower</code> docs for details.</p>"},{"location":"#citing","title":"Citing","text":"<p>If you find the code useful for your own academic research, please cite it.</p> <pre><code>@ARTICLE{2020arXiv201110322M,\nauthor = {{M{\\\"u}hlpfordt}, Tillmann and {Dai}, Xinliang and {Engelmann}, Alexander and {Hagenmeyer}, Veit},\ntitle = \"{Distributed Power Flow and Distributed Optimization -- Formulation, Solution, and Open Source Implementation}\",\njournal = {arXiv e-prints},\nkeywords = {Mathematics - Optimization and Control, Electrical Engineering and Systems Science - Systems and Control},\nyear = 2020,\nmonth = nov,\neid = {arXiv:2011.10322},\npages = {arXiv:2011.10322},\narchivePrefix = {arXiv},\neprint = {2011.10322},\nprimaryClass = {math.OC},\nadsurl = {https://ui.adsabs.harvard.edu/abs/2020arXiv201110322M},\nadsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}\n</code></pre>"},{"location":"assumptions/","title":"Assumptions","text":"<p>Naming convention</p> <p>We distinguish between a master system and several worker systems. The sole difference is that the master system contains the reference bus.</p>"},{"location":"assumptions/#case-file-generator","title":"Case file generator","text":"<ul> <li>The slack bus of the master system is the slack bus of the overall system. </li> <li>Systems can be connected in arbitrary ways at generation buses (i.e. slack buses and/or PV buses), for instance:</li> </ul> <ul> <li>There may be several connections between two systems too.</li> </ul> <p>Warning</p> <p>It is currently not supported to connect several lines between the same buses.</p> <ul> <li>In the to-system we replace the generation bus by a <code>PQ</code> bus with zero generation and original demand.</li> <li>If the connecting generation bus in the to-worker-system is the slack bus, then this slack in the worker system is replaced by a <code>PQ</code> bus with zero generation/demand.</li> <li>On the other hand, if the connecting generation bus in the to-system is a <code>PV</code> bus, then this <code>PV</code> bus is replaced by a <code>PQ</code> bus</li> <li>If no connecting bus in the to-worker-system is the slack bus, then the worker system\u2019s slack bus is replaced by a <code>PV</code> bus; the respective set points for the active power and the voltage magnitude are taken from the <code>Matpower</code> case file entries in <code>mpc.gen</code>.</li> <li>If the master system has N_{m} nodes, and if each worker system i has N_{s, i} nodes for i \\in \\{ 1, \\dots, d \\}, then the overall system is going to have N = N_{m} + N_{s_1} + \\dots + N_{s, d} nodes.</li> <li>The entries for the generated active/reactive power from the fields <code>mpc.gen()</code> are ignored.</li> <li>The numbering of the overall system (= master + workers) goes from 1 to N, where N is the number of buses in the overall system, see above.</li> <li>The master system contains bus numbers 1 to N_m. The numbering of the buses in the remaining systems is done according to order of appearance.</li> <li>All case files have the same <code>baseMVA</code>.</li> <li>The voltage magnitude settings in <code>mpc.gen</code> must be equivalent.</li> <li>If there are several generators at a single bus, then their voltage magnitude must be the same. </li> </ul>"},{"location":"assumptions/#case-file-splitter","title":"Case file splitter","text":"<ul> <li>The copy buses of each region i are added at the end of the list of core buses of region i. Both the list of copy buses and the list of core buses are sorted in ascending order.</li> <li>The bus admittance matrix of region i is created by first splitting the case for region i including the copy buses, and then calling <code>makeYbus</code> (built-in <code>matpower</code> function).</li> </ul>"},{"location":"assumptions/#case-file-parser","title":"Case file parser","text":"<ul> <li>The distributed problem is obtained by copying buses at the connecting lines, and then enforcing consensus at the original buses and their respective copies.</li> <li>The state x_i in every region i is composed of n_{i}^{\\text{core}} core entries and n_{i}^{\\text{copy}} copy entries, where</li> </ul>   x_{i}^{\\text{core}} = ( \\theta_i^{\\text{core}}, v_i^{\\text{core}}, p_i^{\\text{core}}, q_i^{\\text{core}} ) \\in \\mathbb{R}^{4 n_{i}^{\\text{core}}},  <ul> <li>and</li> </ul>  x_{i}^{\\text{copy}} = ( \\theta_i^{\\text{copy}}, v_i^{\\text{copy}}) \\in \\mathbb{R}^{2 n_{i}^{\\text{copy}}}.  <ul> <li>The full state of region i is x_i = (\\theta_i^{\\text{core}}, \\theta_i^{\\text{copy}}, v_i^{\\text{core}}, v_i^{\\text{copy}}, p_i^{\\text{core}}, q_i^{\\text{core}}) \\in \\mathbb{R}^{4 n_i^{\\text{core}} + 2 n_i^{\\text{copy}}}.</li> </ul>"},{"location":"example/","title":"Example","text":"<p>This is a beginning-to-end-example about how to solve distributed power flow with the Aladin toolbox. Click here to see the plain code.</p>"},{"location":"example/#setup","title":"Setup","text":"<p>Starting from the home directory of the package, let\u2019s make a tabula rasa and switch to the use case folder</p> <pre><code>clear all; close all; clc;\ncd('00_use-case')\n</code></pre> <p>If not done already, add the source files to the path</p> <pre><code>addpath(genpath('../01_generator/'));\naddpath(genpath('../02_splitter/'));\naddpath(genpath('../03_parser/'));\n</code></pre> <p>We would like the following fields to be merged from the case files</p> <pre><code>fields_to_merge = {'bus', 'gen', 'branch'};\n</code></pre>"},{"location":"example/#specify-inputs","title":"Specify inputs","text":"<p>We first generate a name struct that acts as a de-facto global variable for naming structs.</p> <pre><code>names = generate_name_struct();\n</code></pre> <p>Next, we specify the master and worker systems by loading their case files.</p> <pre><code>mpc_master  = loadcase('case14');\nmpc_workers = { loadcase('case30'); loadcase('case9')  };\n</code></pre> <p>Additionally, we need to specify who is connected to whom. These connections are specified in a connection array:</p> <pre><code>connection_array = [ 2 1  1 2;\n2 3  2 3; 2 3 13 1; ];\n</code></pre> <p>The first row reads: system 2 is connected to system 1, specifically the first bus of system 2 is connected to the second bus of system 1. Likewise, the second row reads: system 2 is connected to system 3, specifically the second bus of system 2 is connected to the third bus of system 3.</p> <p>However, we need not just to specify who is connected to whom, but also how. Hence, we model a connecting transformer.</p> <pre><code>trafo_params.r = 0;\ntrafo_params.x = 0.00623;\ntrafo_params.b = 0;\ntrafo_params.ratio = 0.985;\ntrafo_params.angle = 0;\n</code></pre> <p>Finally, we can call <code>build_connection_table</code>.</p> <pre><code>conn = build_connection_table(connection_array, trafo_params);\n</code></pre>"},{"location":"example/#problem-formulation","title":"Problem formulation","text":"<p>Having done the setup, we are now ready to use the three main blocks: the case file generator, the case file splitter, and the case file parser:</p>"},{"location":"example/#case-file-generator","title":"Case file generator","text":"<p>Calling the case file generator means to specify the master and the workers together with the connection table, and what fields shall be merged. The most convenient way is to call <code>run_case_file_generator</code></p> <pre><code>mpc_merge = run_case_file_generator(mpc_master, mpc_workers, conn, fields_to_merge, names);\n</code></pre> <p>The output is a case file that has a lot of extra information.</p>"},{"location":"example/#case-file-splitter","title":"Case file splitter","text":"<p>The output of the case file generator is the input to the case file splitter, together with connection information. We call <code>run_case_file_splitter</code></p> <pre><code>mpc_split = run_case_file_splitter(mpc_merge, conn, names);\n</code></pre> <p>The output is, again, a case file that has a lot of extra information.</p>"},{"location":"example/#case-file-parser","title":"Case file parser","text":"<p>Finally, the case file parser takes the output from the splitter, and generates a problem formulation, using <code>generate_distributed_problem_for_aladin</code>. Note that we can need to specify whether we create a <code>feasibility</code> or a <code>least-squares</code> problem formulation.</p> <pre><code>problem = generate_distributed_problem_for_aladin(mpc_split, names, 'least-squares');\n</code></pre> <p>The problem formulation is a struct that contains all relevant equations.</p> <p>Finally, we need to add a numerical solver (<code>fmincon</code>, <code>fminunc</code>, <code>worhp</code>, <code>Casadi+Ipopt</code>)</p> <pre><code>% add a solver\nproblem.solver = 'fmincon';\n</code></pre>"},{"location":"example/#problem-solution","title":"Problem solution","text":"<p>Having created a valid problem formulation, we rely on the Aladin toolbox to solve the problem. Aladin requires a set of parameters (using the default values is also possible, and usually a good idea). We use the function <code>solve_distributed_problem_with_aladin</code></p> <pre><code>opts = struct('maxiter',50, 'solveQP','MA57');\nopts.reg ='false';\nopts.rho0= 1e2;\n\n[xsol_aladin, xsol_stack_aladin, mpc_sol_aladin, logg] = solve_distributed_problem_with_aladin(mpc_split, problem, names, opts);\n</code></pre> <p>The function returns four outputs: <code>xsol_aladin</code> and <code>xsol_stack_aladin</code> are both cells with as many entries as there are regions. In each entry, the state of region i is stored: in <code>xsol_aladin</code> it is a matrix form with as many rows as there are buses in the region, and the four columns being the voltage angle, the voltage magnitude, the net active power, and the net reactive power; in <code>xsol_stack_aladin</code>, each entry is the vertically stacked equivalent of <code>xsol_aladin</code>. The third output, <code>mpc_sol_aladin</code>, is a valid case file that can be used for further inspection. The fourth output contains logging information from the Aladin toolbox.</p>"},{"location":"example/#comparison","title":"Comparison","text":"<p>How do we know that the solution we computed is actually correct? For that purpose, there is a validation function such as <code>validate_distributed_problem_formulation</code>. Simply put, the function uses <code>matpower</code> to validate that the generated problem formulation stored in <code>problem</code> is correct.</p> <pre><code>[xval, xval_stacked] = validate_distributed_problem_formulation(problem, mpc_split, names);\n</code></pre> <p>The outputs have the same format as the first two outputs (<code>xsol_aladin</code> &amp; <code>xsol_stack_aladin</code>) from the problem solution. To compare the results we call <code>compare_results</code>, which generates a humand-readable <code>table</code> output.</p> <pre><code>comparison_aladin = compare_results(xval, xsol_aladin)\n</code></pre>"},{"location":"example/#post-processing","title":"Post-processing","text":"<p>There is a handy function for post-processing, This function provides a graphical impression of the overall constraint violations for both the power flow equations and the consensus violations.</p> <pre><code>compare_constraints_violation(problem, logg);\n</code></pre> <p>For this example the violation of the power flow equations, the bus specifications, and the consensus constraints are shown below per Aladin iteration.</p> <p></p>"},{"location":"example/#entire-code","title":"Entire code","text":"<pre><code>clear all; close all; clc;\n\naddpath(genpath('../01_generator/'));\naddpath(genpath('../02_splitter/'));\naddpath(genpath('../03_parser/'));\n\nnames = generate_name_struct();\n%% setup\nfields_to_merge = {'bus', 'gen', 'branch'};\nmpc_master  = loadcase('case14');\nmpc_workers = { loadcase('case30')\nloadcase('case9')  };\n\nconnection_array = [2 1 1 2;\n2 3 2 3; 2 3 13 1;\n];\n\ntrafo_params.r = 0;\ntrafo_params.x = 0.00623;\ntrafo_params.b = 0;\ntrafo_params.ratio = 0.985;\ntrafo_params.angle = 0;\n\nconn = build_connection_table(connection_array, trafo_params);\n\n%% main\n% case-file-generator\nmpc_merge = run_case_file_generator(mpc_master, mpc_workers, conn, fields_to_merge, names);\n% case-file-splitter\nmpc_split = run_case_file_splitter(mpc_merge, conn, names);\n% generate problem formulation for aladin\nproblem = generate_distributed_problem_for_aladin(mpc_split, names, 'least-squares');\n% add a solver\nproblem.solver = 'fmincon';\n% validate problem formulation\n[xval, xval_stacked] = validate_distributed_problem_formulation(problem, mpc_split, names);\n\nopts = struct('maxiter',50, 'solveQP','MA57');\nopts.reg ='false';\nopts.rho0= 1e2;\n\n[xsol_aladin, xsol_stack_aladin, mpc_sol_aladin, logg] = solve_distributed_problem_with_aladin(mpc_split, problem, names, opts);\n\ncomparison_aladin = compare_results(xval, xsol_aladin)\ncompare_constraints_violation(problem, logg);\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":"<p>Once you have setup everything correctly, the easiest way to get started, is to play with some implemented test cases. Simply open and run <code>00_use-case/getting_started.m</code>. This will open a GUI, from which you can select a case of your choice. In addition, you can select the problem type, and the solver with which to solve the problem.</p> <p></p> <p>A more detailed example is covered here.</p> <p>External solvers</p> <p>For Casadi and worhp to work you need to make sure they run on your machine.</p>"},{"location":"installation/","title":"Installation","text":"<ul> <li>Install <code>Matlab</code>.</li> <li>Add <code>Matpower</code> to your <code>Matlab</code> installation</li> <li>Add <code>CasADi</code> to your <code>Matlab</code> installation. </li> <li>Add <code>Aladin</code> to your <code>Matlab</code> installation.<ul> <li>Make sure to switch to the <code>abstractify</code> branch if you want to use Aladin without Casadi.</li> </ul> </li> </ul> <p>Branch <code>abstractify</code></p> <p>The branch <code>abstractify</code> is actively being developed. Be prepared to see breaking changes and unintended behavior.</p> <p>Use of <code>matpower</code></p> <p>The code relies heavily on <code>Matpower</code>, especially on the idea of a <code>matpower case file</code> (or <code>mpc</code>). This bulky name is nothing but a standardized <code>Matlab</code> struct, with the advantage that it has become a de facto standard for Matlab-based power systems research. Also, <code>mpc</code> can be converted within <code>matpower</code> to/from IEEE CDF or PSS/E RAW, see the <code>Matpower</code> docs for details.</p>"},{"location":"overview/","title":"Overview","text":"<p>The code consists of three main blocks, listed in the following table.</p> Name Function Case file generator Merge several case files &amp; connection information Case file splitter Adjust case files to account for core and copy nodes Case file parser Generate mathematical problem formulation <p>Their relationship is shown in the following:</p> <p></p> <p>The interface of the blocks is made up of matpower case files. This allows to leverage all of the built-in functionality that comes with <code>matpower</code>.</p> <p>Visualizing case files</p> <p>There is an exquisite open source tool for visualizing case files: simply drag and drop a valid case file and be merry.</p> <p>Specifically the input to the case file generator consists of several case files and their connection information; the connection information encodes who is connected to whom and by what kind of transformer. The output of the case file generator is, again, a case file, which is then fed to the case file splitter. The splitter adds information to each individual case file about neighboring buses. This is then fed to the caes file parser (in the form of a case file) whose output is a mathematial problem formulation in terms of function handles. The case file parser also generates sensitivities of the power flow problem.</p>"},{"location":"overview/#allowed-connections","title":"Allowed connections","text":"<p>Systems can be connected in arbitrary ways at generation buses, for instance:</p> <p></p> <p></p> <p></p> <p>There may be several connections between two systems too.</p> <p></p> <p>Warning</p> <p>It is currently not supported to connect several lines between the same buses.</p>"},{"location":"problem-formulation/","title":"Problem formulation","text":"<p>Here we present the mathematical formulation of the distributed power flow problem, which simply reads</p> \\begin{aligned}         g^{\\text{pf}}_i( x_i, z_i ) &amp;= 0 \\\\         g^{\\text{bus}}_i ( x_i ) &amp;= 0 \\\\         \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix}             x_i \\\\             z_i         \\end{bmatrix}         &amp;= 0.     \\end{aligned} <p>In plain words, the first set of equations satisfies the power flow equations in each region\u00a0i, the second set of equations accounts for the bus specifications, and the third set of equations ensures consensus among the nodes that are shared between regions (will be explained below).</p> <p>Its advantage is that its solution\u2014supposing it exists\u2014is mathematically equivalent to the original power flow problem. Instead of often done splitting of lines we simply copy neighboring buses within regions.</p> <p>With rapidPF, the distributed power flow problem can be solved in two different problem formulations:</p> <ul> <li>as a distributed feasibility problem,</li> <li>or as a distributed least-squares problem.</li> </ul> <p>What problem formulation to use</p> <p>From our experience, the distributed least-squares formulation works better.</p>"},{"location":"problem-formulation/#core-nodes-copy-nodes","title":"Core nodes &amp; copy nodes","text":"<p>Suppose we have a grid that looks like as follows</p> <p></p> <p>There are a total of 12 buses in the system. The dashed lines indicate the three different regions: buses \\{ 1, 2, 3 \\} belong to what we call the master system, buses \\{4, 5, 6, 7 \\} belong to what we call the (first) worker system, and buses \\{ 8, 9, 10, 11, 12 \\} belong to the (second) worker system. Hence, we distinguish between master and worker systems; these local or regional systems (or just subsystems) make up the overall power system.</p> <p>For the overall system the power flow problem means to compute the values</p> \\begin{aligned}     x_i = \\begin{bmatrix}         \\theta_i \\\\         v_i \\\\         p_i \\\\         q_i \\\\     \\end{bmatrix}     \\in \\mathbb{R}^{4 n}\\end{aligned} <p>for all i \\in \\{1, \\dots, 12 \\}. A prototypical power flow problem can be formulated mathematically as a system of nonlinear equations of the form</p> \\begin{aligned}         g^{\\text{pf}}( x) &amp;= 0, \\\\         g^{\\text{bus}}( x) &amp;= 0,     \\end{aligned} <p>where g^{\\text{pf}}( x) = 0 constitutes the 2 \\times 12 power flow equations, and g^{\\text{bus}}( x) = 0 stands for the remaining 2 \\times 12 bus specifications. This yields a total of 4 \\times 12 equations for 4 \\times 12 unknowns. Arguably, this leads to large systems of nonlinear equations as soon as the number of buses in the power system increases. From here on we call this prototypical power flow problem we just described the centralized power flow problem.</p> <p>The idea of distributed power flow is to solve local power flow problems within each system (= the master system, and all of the worker systems), independent of each other, and iterate for as long as necessary until the solution of the centralized problem is obtained. Iteration here means to find consensus on the physical values of the exchanged power between the subsystems.</p> <p>Before making this idea mathematically precise we introduce some more Nomenclature. Suppose we are seated in the master system, the one composed of buses \\{1, 2, 3 \\}. From our perspective both worker systems are our neighbors. More precisely, we know only that bus 4 (located in the first worker system) is our connection to the first worker system. Likewise, bus 8 (located in the second worker system) is our connection to the second worker system. To distinguish between these different kinds of buses we call the buses \\{1, 2, 3 \\} the core nodes of the master system, and buses \\{ 4, 8\\} the copy nodes. Importantly, all other nodes do not exist for us; they are ignored. Graphically, our world looks as follows.</p> <p></p> <p>Why the term copy? Because when formulating the power flow equations for the master system we need to know the voltages at the copy nodes. And in case we don\u2019t know the values (which we really don\u2019t because the copy nodes do not belong to our jurisdiction), then we have to assume values for them. This can be thought of as copying the buses into the shaded are denoted as \u201c\\text{copy + core nodes},\u201d hence the name.</p> <p>Taking on the perspective of the first worker system we see: our core nodes are \\{ 4, 5, 6, 7 \\}, and there is just one copy bus 1, the first bus in the master system. Our world looks as follows.</p> <p></p> <p>Being able to distinguish between core nodes and copy nodes allows to formulate the distributed power flow clearer: solve the power flow problem in each subsystem and attain consensus between the copy nodes and their core node equivalents. By core node equivalent we mean the following: the first copy bus of the master system has bus 4 as its core node equivalent. It is clear from intuition that if the voltage at the copy node in each subsystem corresponds to the value of its core node equivalent, then the solution of the distributed power flow problem is the same as the solution from the centralized power flow problem.</p> <p>Let us make these ideas mathematically more precise.</p>"},{"location":"problem-formulation/#local-power-flow-problem","title":"Local power flow problem","text":"<p>The following table collects symbols and their meanings as they are used throughout.</p> Symbol Meaning n^{\\text{reg}} Number of regions n^{\\text{conn}} Number of connecting lines between regions n^\\text{core}_{i} Number of core nodes in region i n^\\text{copy}_{i} Number of copy nodes in region i x_{i} State of core nodes in region i z_{i} State of copy nodes in region i <p>We compose the set of buses of each region i into a set of core nodes, and a set of copy nodes. The core nodes are the original nodes that make up the power system. The copy nodes are the nodes that connect the power system to the neighboring power systems. Hence, the copy nodes do not belong to the power system but to its neighbors. The sole purpose of the copy nodes is to store the complex voltage information at the neighboring buses such that power flow equations can be constructed.</p> <p>The state of the core nodes contains the voltage angles, the voltage magnitudes, the net active power, and the net reactive power of all core nodes</p> \\begin{aligned}     \\label{eq:state-core}     x_i = \\begin{bmatrix}         \\theta_i^\\text{core} \\\\         v_i^\\text{core} \\\\         p_i^\\text{core} \\\\         q_i^\\text{core} \\\\     \\end{bmatrix}     \\in \\mathbb{R}^{4 n^\\text{core}_i}.\\end{aligned} <p>The state of the copy nodes contains the voltage angles and the voltage magnitudes of all copy nodes</p> \\begin{aligned}     \\label{eq:state-copy}     z_i = \\begin{bmatrix}         \\theta_i^\\text{copy} \\\\         v_i^\\text{copy}     \\end{bmatrix}     \\in \\mathbb{R}^{2 n^\\text{copy}_i}.\\end{aligned} <p>We see: each region i is described by a total of 4 n^\\text{core}_i + 2 n^\\text{copy}_i real numbers.</p>"},{"location":"problem-formulation/#power-flow-equations","title":"Power flow equations","text":"<p>In region i we formulate a total of 2 n^\\text{core}_i power flow equations g^{\\text{pf}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\times \\mathbb{R}^{2 n^\\text{copy}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} for all core nodes</p> \\begin{aligned}     g^{\\text{pf}}_i( x_i, z_i) = 0.\\end{aligned}"},{"location":"problem-formulation/#bus-specifications","title":"Bus specifications","text":"<p>In region i we formulate a total of 2 n^\\text{core}_i bus specifications g^{\\text{bus}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} for all core nodes</p> \\begin{aligned}     g^{\\text{bus}}_i( x_i) = 0.\\end{aligned}"},{"location":"problem-formulation/#degrees-of-freedom","title":"Degrees of freedom","text":"<p>Subtracting the number of equations from the number of decision variables gives us a total of</p> \\begin{aligned}     \\underbrace{4 n^\\text{core}_i + 2 n^\\text{copy}_i}_{\\text{Decision variables}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Power flow equations}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Bus specifications}} = \\underbrace{2 n^\\text{copy}_i}_{\\text{Degrees of freedom}}\\end{aligned} <p>degrees of freedom for each region\u00a0i. These degrees of freedom must be fixed globally by the consensus constraints.</p>"},{"location":"problem-formulation/#decentralized-power-flow-problem","title":"Decentralized power flow problem","text":"\\begin{aligned}         g^{\\text{pf}}_i( x_i, z_i ) &amp;= 0 \\\\         g^{\\text{bus}}_i ( x_i ) &amp;= 0 \\\\         \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix}             x_i \\\\             z_i         \\end{bmatrix}         &amp;= 0,     \\end{aligned} <p>where the consensus matrices A_i \\in \\mathbb{R}^{4 n^{\\text{conn}}\\times (4 n^\\text{core}_i + 2 n^\\text{copy}_i)} enforce equality of the voltage angle and the voltage magnitude at the copy buses and their respective original buses.</p>"},{"location":"sensitivities/","title":"Sensitivities","text":""},{"location":"sensitivities/#sensitivities","title":"Sensitivities","text":"<p>This section shows how the power flow sensitivities can be used.</p> <p>All gradient-based optimization methods require sensitivities. By sensitivities we mean one (or all) of the following:</p> <ul> <li>gradients,</li> <li>Jacobians, and/or</li> <li>Hessians.</li> </ul> <p>Broadly speaking, there are three ways to obtain sensitivities:</p> <ul> <li>symbolically,</li> <li>numerically,</li> <li>by automatic differentiation,</li> </ul> <p>with each method having its own pros and cons. The case file parser does not just provide the mathematical problem formulation in terms of function handles, but also sensitivities.</p>"},{"location":"sensitivities/#computation","title":"Computation","text":"<p>Naming for sensitivities</p> <p>The naming of the sensitivities is inspired by the naming conventions from Aladin.</p> <p>Letting <code>problem</code> be the output of the case file parser, you find it has an entry <code>sens</code></p> <pre><code>&gt;&gt; problem.sens\n\nans = struct with fields:\n\ngg: {3\u00d71 cell}\nJJac: {3\u00d71 cell}\nHH: {3\u00d71 cell}\n</code></pre> <p>which has again three entries. The following table gives some background information.</p> Entry Meaning Definition Exact <code>gg</code> Gradient of each local cost function (see Algorithm 1 here) \\nabla f_i(x_i) (zero for power flow problems) Yes <code>JJac</code> Jacobian of each local power flow problem J_{g_i}(x_i, z_i) where g_i(x_i, z_i) = \\begin{bmatrix} g^{\\text{pf}}_i( x_i, z_i ) \\\\ g^{\\text{bus}}_i ( x_i )) \\end{bmatrix} Yes <code>HH</code> Hessian of each local problem for Aladin problem formulation (see Algorithm 1 here) \\nabla^2 B_i with B_i = f_i(x_i) + \\kappa_i^\\top g_i(x_i, z_i), where \\kappa_i are the Lagrange multipliers w.r.t. the equality constraints g_i No <p>The Hessian is computed numerically using central differences per default for the feasibility formulation, and by the Gauss-Newton method for the least-squares formulation.</p> <p>These sensitivities should be supplied to numerical solvers to increase both accuracy and speed.</p> <p>Where sensitivities are computed</p> <p>The sensitivities are computed in the file <code>generate_local_power_flow_problem.m</code>.</p>"},{"location":"sensitivities/#example","title":"Example","text":"<p>Suppose we are interested in power flow for a single-region problem, i.e. a traditional non-distributed setup. Then, we know that we can just apply Newton\u2019s method, for which we need both the equality constraints that specify the power flow problem, and its Jacobian. So, purely for cross validation, let\u2019s solve a power flow problem using the information the case file splitter provides.</p> <pre><code>mpc = ext2int(loadcase('case30'));\nmpc.(names.regions.global) = 1:30;\nmpc.(names.copy_buses.local) = [];\n[cost, ineq, eq, x0, pf, bus_specifications, Jac] = generate_local_power_flow_problem(mpc, names, 'not_required', 'feasibility');\n</code></pre> <p>Lines 2 and 3 are needed purely for code convention routines: they introduce a sense of global numbering, and specify no neighors. The last line calls the case file parser which returns the Jacobian. Running a prototypical Newton scheme is then straightforward</p> <pre><code>x = x0;\ntol = 1e-10;\ni = 0;\n\nwhile norm(eq(x)) &gt; tol &amp;&amp; i &lt; 10\nx = x - Jac(x) \\ eq(x);\nnorm(eq(x))\ni = i + 1;\nend\n</code></pre> <p>Putting this together for our example system we have</p> <pre><code>clear all; close all; clc;\n\naddpath(genpath('../01_generator/'));\naddpath(genpath('../02_splitter/'));\naddpath(genpath('../03_parser/'));\n\nnames = generate_name_struct();\n%% setup\nfields_to_merge = {'bus', 'gen', 'branch'};\nmpc_master  = loadcase('case14');\nmpc_slaves = { loadcase('case30')\nloadcase('case9')  };\n\nconnection_array = [2 1 1 2;\n2 3 2 3; 2 3 13 1;\n];\n\ntrafo_params.r = 0;\ntrafo_params.x = 0.00623;\ntrafo_params.b = 0;\ntrafo_params.ratio = 0.985;\ntrafo_params.angle = 0;\n\nconn = build_connection_table(connection_array, trafo_params);\n\n%% main\n% case-file-generator\nmpc_merge = run_case_file_generator(mpc_master, mpc_slaves, conn, fields_to_merge, names);\n% case-file-splitter\nmpc_split = run_case_file_splitter(mpc_merge, conn, names);\n\nmpc = ext2int(loadcase('case30'));\nmpc.(names.regions.global) = 1:30;\nmpc.(names.copy_buses.local) = [];\n[cost, ineq, eq, x0, pf, bus_specifications, Jac] = generate_local_power_flow_problem(mpc, names, 'my_postfix', 'feasibility');\n\nx = x0;\ntol = 1e-10;\ni = 0;\n\nwhile norm(eq(x)) &gt; tol &amp;&amp; i &lt; 10\nx = x - Jac(x) \\ eq(x);\nnorm(eq(x))\ni = i + 1;\nend\n</code></pre>"},{"location":"mfiles/01_generator/create_skeleton_mpc/","title":"create_skeleton_mpc","text":"<p><code>mpc = create_skeleton_mpc(data, field_names, names)</code></p> <p>Create a skeleton case file from <code>data</code> and the specified <code>field_names</code></p>"},{"location":"mfiles/01_generator/merge_systems/","title":"merge_systems","text":"<p><code>mpc = merge_systems(mpc_master, mpc_worker, pars, names)</code></p> <p>Merge the master system and the worker system to another case file <code>mpc</code></p> <p>The physical information about the connecting transformer is stored in <code>pars</code>.</p>"},{"location":"mfiles/01_generator/run_case_file_generator/","title":"run_case_file_generator","text":"<p><code>mpc = run_case_file_generator(mpc_master, mpc_workers, connection_table, fields_to_merge, names)</code></p> <p>Generate a merged case file <code>mpc</code> from <code>mpc_master</code> and <code>mpc_workers</code> according to the <code>connection_table</code></p> <p>The auxiliary inputs <code>fields_to_merge</code> and <code>names</code> are basic requirements with obvious meanings.</p>"},{"location":"mfiles/02_splitter/add_consensus_information/","title":"add_consensus_information","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/02_splitter/add_consensus_information/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/02_splitter/run_case_file_splitter/","title":"run_case_file_splitter","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/02_splitter/run_case_file_splitter/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/02_splitter/split_case_file/","title":"split_case_file","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/02_splitter/split_case_file/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/build_consensus_constraints/","title":"build_consensus_constraints","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/build_consensus_constraints/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/create_bus_specifications/","title":"create_bus_specifications","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/create_bus_specifications/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/create_power_flow_equation_for_p/","title":"create_power_flow_equation_for_p","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/create_power_flow_equation_for_p/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/create_power_flow_equation_for_q/","title":"create_power_flow_equation_for_q","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/create_power_flow_equation_for_q/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/generate_distributed_problem/","title":"generate_distributed_problem","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/generate_distributed_problem/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/solve_distributed_problem_centralized/","title":"solve_distributed_problem_centralized","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/solve_distributed_problem_centralized/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/solve_distributed_problem_with_aladin/","title":"solve_distributed_problem_with_aladin","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/solve_distributed_problem_with_aladin/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"},{"location":"mfiles/03_parser/validate_distributed_problem_formulation/","title":"validate_distributed_problem_formulation","text":"<p><code>copy the declaration of the function in here (leave the ticks unchanged)</code></p> <p>describe what the function does in the following line</p>"},{"location":"mfiles/03_parser/validate_distributed_problem_formulation/#markdown-formatting-is-supported","title":"Markdown formatting is supported","text":"<p>Equations are possible to, e.g a^2 + b^2 = c^2. So are lists:</p> <ul> <li> <p>item 1</p> </li> <li> <p>item 2</p> </li> </ul> <pre><code>function y = square(x)\n\nx^2\nend\n</code></pre> <p>See also: run_case_file_splitter</p>"}]}